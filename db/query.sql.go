// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAuthCredentials = `-- name: CreateAuthCredentials :one

INSERT INTO auth_credentials (
    user_id,
    password_hash
) VALUES ($1, $2)
RETURNING id, user_id, password_hash, email_verified_at, last_login_at, failed_login_attempts, locked_until, created_at, updated_at, deleted_at
`

type CreateAuthCredentialsParams struct {
	UserID       int64
	PasswordHash string
}

// Auth Credentials Queries
func (q *Queries) CreateAuthCredentials(ctx context.Context, arg CreateAuthCredentialsParams) (AuthCredential, error) {
	row := q.db.QueryRow(ctx, createAuthCredentials, arg.UserID, arg.PasswordHash)
	var i AuthCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PasswordHash,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createEvent = `-- name: CreateEvent :one
INSERT INTO events (
  organisation_id,
  name,
  slug)
VALUES ($1, $2, $3)
RETURNING id, organisation_id, name, slug, created_at, updated_at, deleted_at
`

type CreateEventParams struct {
	OrganisationID int64
	Name           string
	Slug           string
}

func (q *Queries) CreateEvent(ctx context.Context, arg CreateEventParams) (Event, error) {
	row := q.db.QueryRow(ctx, createEvent, arg.OrganisationID, arg.Name, arg.Slug)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createOrganisation = `-- name: CreateOrganisation :one
INSERT INTO organisations (
  name)
VALUES ($1)
RETURNING id, name, created_at, updated_at, deleted_at
`

func (q *Queries) CreateOrganisation(ctx context.Context, name string) (Organisation, error) {
	row := q.db.QueryRow(ctx, createOrganisation, name)
	var i Organisation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
  email,
  first_name,
  last_name,
  phone,
  address_line1,
  address_line2,
  city,
  state,
  postal_code,
  country,
  role)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
RETURNING id, email, first_name, last_name, phone, address_line1, address_line2, city, state, postal_code, country, role, created_at, updated_at, deleted_at
`

type CreateUserParams struct {
	Email        string
	FirstName    string
	LastName     string
	Phone        pgtype.Text
	AddressLine1 pgtype.Text
	AddressLine2 pgtype.Text
	City         pgtype.Text
	State        pgtype.Text
	PostalCode   pgtype.Text
	Country      pgtype.Text
	Role         UserRole
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Phone,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Role,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const deleteEvent = `-- name: DeleteEvent :exec
UPDATE events
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteEvent(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteEvent, id)
	return err
}

const deleteOrganisation = `-- name: DeleteOrganisation :exec
UPDATE organisations
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteOrganisation(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteOrganisation, id)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
UPDATE users
SET deleted_at = NOW()
WHERE id = $1
`

func (q *Queries) DeleteUser(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteUser, id)
	return err
}

const getAuthCredentialsByEmail = `-- name: GetAuthCredentialsByEmail :one
SELECT ac.id, ac.user_id, ac.password_hash, ac.email_verified_at, ac.last_login_at, ac.failed_login_attempts, ac.locked_until, ac.created_at, ac.updated_at, ac.deleted_at FROM auth_credentials ac
INNER JOIN users u ON ac.user_id = u.id
WHERE u.email = $1
AND ac.deleted_at IS NULL
AND u.deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetAuthCredentialsByEmail(ctx context.Context, email string) (AuthCredential, error) {
	row := q.db.QueryRow(ctx, getAuthCredentialsByEmail, email)
	var i AuthCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PasswordHash,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getAuthCredentialsByUserID = `-- name: GetAuthCredentialsByUserID :one
SELECT id, user_id, password_hash, email_verified_at, last_login_at, failed_login_attempts, locked_until, created_at, updated_at, deleted_at FROM auth_credentials
WHERE user_id = $1
AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetAuthCredentialsByUserID(ctx context.Context, userID int64) (AuthCredential, error) {
	row := q.db.QueryRow(ctx, getAuthCredentialsByUserID, userID)
	var i AuthCredential
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.PasswordHash,
		&i.EmailVerifiedAt,
		&i.LastLoginAt,
		&i.FailedLoginAttempts,
		&i.LockedUntil,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getEvent = `-- name: GetEvent :one
SELECT id, organisation_id, name, slug, created_at, updated_at, deleted_at from events
WHERE slug = $1 LIMIT 1
`

func (q *Queries) GetEvent(ctx context.Context, slug string) (Event, error) {
	row := q.db.QueryRow(ctx, getEvent, slug)
	var i Event
	err := row.Scan(
		&i.ID,
		&i.OrganisationID,
		&i.Name,
		&i.Slug,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getOrganisation = `-- name: GetOrganisation :one
SELECT id, name, created_at, updated_at, deleted_at from organisations
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetOrganisation(ctx context.Context, id int64) (Organisation, error) {
	row := q.db.QueryRow(ctx, getOrganisation, id)
	var i Organisation
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT id, email, first_name, last_name, phone, address_line1, address_line2, city, state, postal_code, country, role, created_at, updated_at, deleted_at from users
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, id int64) (User, error) {
	row := q.db.QueryRow(ctx, getUser, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, first_name, last_name, phone, address_line1, address_line2, city, state, postal_code, country, role, created_at, updated_at, deleted_at FROM users
WHERE email = $1
AND deleted_at IS NULL
LIMIT 1
`

func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Phone,
		&i.AddressLine1,
		&i.AddressLine2,
		&i.City,
		&i.State,
		&i.PostalCode,
		&i.Country,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return i, err
}

const incrementFailedLoginAttempts = `-- name: IncrementFailedLoginAttempts :exec
UPDATE auth_credentials
SET failed_login_attempts = failed_login_attempts + 1
WHERE user_id = $1
`

func (q *Queries) IncrementFailedLoginAttempts(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, incrementFailedLoginAttempts, userID)
	return err
}

const isAccountLocked = `-- name: IsAccountLocked :one
SELECT
    CASE
        WHEN locked_until IS NULL THEN false
        WHEN locked_until > NOW() THEN true
        ELSE false
    END as is_locked
FROM auth_credentials
WHERE user_id = $1
`

func (q *Queries) IsAccountLocked(ctx context.Context, userID int64) (bool, error) {
	row := q.db.QueryRow(ctx, isAccountLocked, userID)
	var is_locked bool
	err := row.Scan(&is_locked)
	return is_locked, err
}

const listEvents = `-- name: ListEvents :many
SELECT id, organisation_id, name, slug, created_at, updated_at, deleted_at from events
ORDER BY name
`

func (q *Queries) ListEvents(ctx context.Context) ([]Event, error) {
	rows, err := q.db.Query(ctx, listEvents)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Event
	for rows.Next() {
		var i Event
		if err := rows.Scan(
			&i.ID,
			&i.OrganisationID,
			&i.Name,
			&i.Slug,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const lockAccount = `-- name: LockAccount :exec
UPDATE auth_credentials
SET locked_until = $2
WHERE user_id = $1
`

type LockAccountParams struct {
	UserID      int64
	LockedUntil pgtype.Timestamptz
}

func (q *Queries) LockAccount(ctx context.Context, arg LockAccountParams) error {
	_, err := q.db.Exec(ctx, lockAccount, arg.UserID, arg.LockedUntil)
	return err
}

const updateEvent = `-- name: UpdateEvent :exec
UPDATE events
SET name = $2,
    slug = $3
WHERE id = $1
RETURNING id, organisation_id, name, slug, created_at, updated_at, deleted_at
`

type UpdateEventParams struct {
	ID   int64
	Name string
	Slug string
}

func (q *Queries) UpdateEvent(ctx context.Context, arg UpdateEventParams) error {
	_, err := q.db.Exec(ctx, updateEvent, arg.ID, arg.Name, arg.Slug)
	return err
}

const updateLastLogin = `-- name: UpdateLastLogin :exec
UPDATE auth_credentials
SET last_login_at = NOW(),
    failed_login_attempts = 0,
    locked_until = NULL
WHERE user_id = $1
`

func (q *Queries) UpdateLastLogin(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, updateLastLogin, userID)
	return err
}

const updateOrganisation = `-- name: UpdateOrganisation :exec
UPDATE organisations
SET name = $2
WHERE id = $1
RETURNING id, name, created_at, updated_at, deleted_at
`

type UpdateOrganisationParams struct {
	ID   int64
	Name string
}

func (q *Queries) UpdateOrganisation(ctx context.Context, arg UpdateOrganisationParams) error {
	_, err := q.db.Exec(ctx, updateOrganisation, arg.ID, arg.Name)
	return err
}

const updateUser = `-- name: UpdateUser :exec
UPDATE users
SET email = $2,
    first_name = $3,
    last_name = $4,
    phone = $5,
    address_line1 = $6,
    address_line2 = $7,
    city = $8,
    state = $9,
    postal_code = $10,
    country = $11,
    role = $12
WHERE id = $1
RETURNING id, email, first_name, last_name, phone, address_line1, address_line2, city, state, postal_code, country, role, created_at, updated_at, deleted_at
`

type UpdateUserParams struct {
	ID           int64
	Email        string
	FirstName    string
	LastName     string
	Phone        pgtype.Text
	AddressLine1 pgtype.Text
	AddressLine2 pgtype.Text
	City         pgtype.Text
	State        pgtype.Text
	PostalCode   pgtype.Text
	Country      pgtype.Text
	Role         UserRole
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) error {
	_, err := q.db.Exec(ctx, updateUser,
		arg.ID,
		arg.Email,
		arg.FirstName,
		arg.LastName,
		arg.Phone,
		arg.AddressLine1,
		arg.AddressLine2,
		arg.City,
		arg.State,
		arg.PostalCode,
		arg.Country,
		arg.Role,
	)
	return err
}

const verifyEmail = `-- name: VerifyEmail :exec
UPDATE auth_credentials
SET email_verified_at = NOW()
WHERE user_id = $1
`

func (q *Queries) VerifyEmail(ctx context.Context, userID int64) error {
	_, err := q.db.Exec(ctx, verifyEmail, userID)
	return err
}
